## 动态规划

### 思路

选择很重要,当你走到i阶段时候,你有哪些选择,这些可选择列表应该保存下来,这些选择以后一定会用到递推公式当中.

eg上到N阶台阶时候,有多少种走法,  可以走1个台阶或者两个台阶.

拓展:如果一次可以走1,2,,3..m个台阶,那么上到N阶有多少种走法?  这个选择列表就多起来了.



在已经跨过了哪些阶段后,你所有的几种选择,

列出所有可能出现情况的列表,这个列表可以是一维的,也可以是二维的,如果是二维的,就用二维的数组去当缓冲,如果空间复杂度能降到o1就最好了,

**回溯和动态规划的区别:**

回溯是暴力枚举,有着大量的重复计算,  动态规划只需要求出多少种解而已,所有尽量不要用递归,用二维数组保存过程量就可以,如果只要求解的数量,那推荐动态规划,因为回溯时间复杂度成指数增长.



> 思路:
>
> 1.  考虑到会影响i阶段数值变化的所有变量,例如i-1,i-2,i-3等等,它可能是O(1),也可能是O(n)
> 2. 给出i阶段的所有可选择列表,依次给出依赖项,i-1,i-2等的可选择列表,
> 3. 可选择列表的数量和所有有关系的变量数量的乘积就是一个二维数组,这个数组就是解题关键.
>
> 例如,i阶段有三种选择,是红绿蓝都可以,那i-1阶段就只能有2种选择,共6种,
>
> 总结是:每个变量可选择列表的数量全部一一相乘, N1*N2 *N3 *N4



### 房屋偷盗

![1653617462627](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1653617462627.png)





![1653657122151](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1653657122151.png)



在第四个房子时,i为4,小偷所能偷盗财产的最大值为f(4),那么小偷不一定选第四个房子,对吧,那第二个房子之前的最大值为f(2),f(4)可能是f(2)+4的值得来的,也可能直接是f(3)的值,停住了,f(3)等于999999,所以取她们两者间的最大值即可.

### 环形房屋偷盗







### 翻转01字符串

```c++
class Solution {
public:
    int minFlipsMonoIncr(string s) {
        int n = s.size();
        vector< vector<int> > dp(n,vector<int>(2,0));
        dp[0][0] = s[0] != '0';
        dp[0][1] = s[0] != '1';
        for(int i = 1; i < n; ++i) {
            if(s[i] == '0') {
                dp[i][0] = dp[i-1][0];
                dp[i][1] = min(dp[i-1][0],dp[i-1][1]) + 1;
            }
            else {
                dp[i][0] = dp[i-1][0] + 1;
                dp[i][1] = min( dp[i-1][0] ,dp[i-1][1] );
            }
        }
        return min(dp[n-1][0],dp[n-1][1]);
    }
};
```

i-1是已经完成时,i是进行时,但是它加上当前的值的话,那就表示完成时了.

dp[i] [i的可选择列表] 注意:i的可选择列表都应该写全,但是有些是不能选择的哦.

二维数组就是一个变量的**最大可选择列表*****涉及到的变量数**

注意:

这里的选择列表是什么,是选择翻转成0还是翻转成1.  每个题目的选择都不同

### 最长斐波那契数列

![1653743397940](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1653743397940.png)





这里的dp[i] [i的可选择列表j],这个j注意是i可以选择可哪个索引搭配成斐波那契数列,这也是一种选择,注意逆向思维,然后,看看数组前面是否存在k+j=i成立,如果成立的话,+1哦.

### 最少回文字符串切割次数(自己码一下)

### 97子序列的数目

s为`[rablb]`         t为`[rab]`

假如i和j都在最后一个b上,首先我们都去掉这个b变成

`[rabl]` 和     `[ra]`

这里就算b之前有几个不带b只有ra的子序列数

那么你t中出现了b,   s中也遇到相同的b,这仅仅是低消了而已,也就是数目保持不变,我还要看看你有没有更多的b,也就先舍弃这个b,相当于就减1了.

`[rabl]`    和 `[rab]`

这个是查询额外新增b以后,查看是否还会有更多的b,这舍弃这个原本就有的,也就是f(i,j)  和f(i-1,j-1),

看看f(i-1,j)舍弃一个b后是否还有新的数目,如果有,表示什么,表示还有更多的b.

你t加一个b, 我s也可以加一个b,我甚至可以加n多个b,我还可以加别的杂质,,ok,我把这个匹配的b先删除掉,看看你还能匹配不,我t已经加了一个b了,我同时又反手删了s的一个b,我看你到底还有多了几个b,如果都是多的杂质,你可能一个都匹配不上,如果多几个b,数目就新增几个...这个是难点啊!!!

多复习总结!!





## 矩阵路径问题

### 面试题_98











### 面试题_99

找到i-1和i的一个变化流程,这个变换会对结果产生什么影响,我们只考虑会对结果产生影响的选择作为记录,

如果是一维i中,只能看i和i-1或者i-m的变换关系,先看i和i-m他们有什么选择空间,分类讨论,在特定的选择后,所存在的变换关系,

抓住两点,一个是  i和i-1共有的所有选择,考虑周到,这就设计到缓存数组的大小了,如果i有3种选择,i只与i-1有关系和影响,

第二点,在这个多选择列表中,用条件判断 ,进入特定的选择空间,在特定的选择条件后,我们就可以可观的看出,i和i-1变换对结果的影响了.





如果是二位i,j,一般都是  0-i,0-j,那不仅要看i和i-1的变换,还要看i与j之间的变换带来的影响.





### 面试题_100

这个题注意一下碰壁思维, 要考虑一下边界条件哦!!!





## 背包问题

### 面试题_100

### 面试题_101

### 面试题_102

### 面试题_103

### 面试题_104



### 思路



选择:自由的

约束:限制的

DP[]数组代表的含义: 在几种状态下,所能达到的最大值!!一定要把原问题拆解成子问题,子问题和原问题不一样.









**房屋偷盗**

  0到i,影响因素有三个i和i-1和i-2, 当前的值不确定,选择是偷与不偷.

他将偷与不偷的这种选择变成了一个求最值,在偷与不偷的情况下,比较一下就可以啦,所以一维

**刷粉色房子**

 遍历0到i,但影响因素只有i和i-1,当前的值不确定,选择是涂红绿蓝其中之一.

求最少成本   [i] [j]  i长度拉满,然后j是表示i的可选结果, j可以是红绿蓝,最终是这三者的比较,没有拉满

]

**翻转字符**

  最少翻转次数变成0在1之前, 0到i,影响因素只有i和i-1 当前的值不确定,是0还是1, 选择:翻转or不翻转

**最长斐波那契数列**

给定数组的一个子序列,中间可漏元素,形成斐波那契格式,求一个最长的

**最少回文分割**

给定字符串,求最少分割次数使得子字符串是回文形式



**最长公共子序列**

一样,子序列,中间元素可漏,求出最长的公共子序列

**字符串交织**

按顺序,两字符串交织一起,其实也就是一个字符串在不确定的位置按顺序插入某一个字符串,判断能否交织成另外的一个字符串

**子序列的数目**

还是一句话,数组中元素可漏,问可以形成多少个给定的子序列的数目  appplcd  与appc

**01背包**

w承重,给了N个物品,已经他们的承重和价值,问不超过承重情况下,怎么放入背包使得价值最大化?







每个元素他可能没有自己的属性,但一定有他的选择

元素i的选择写里面,在既定i的选择之后,i-1会受到什么影响,要分类讨论一下.而dp数值前面i是必备的,j可以是一个给定的状态,对,就是状态.

和为sum,------>   dp[i] [约束]  这个sum就是约束   ,真的牛逼!!!!!!!! 这个sum和i也叫做参数哦入参

i变成i+1,sum变成 sum-[i]  这不就是回溯吗?????



约束条件和索引

对于i索引的拿于不拿,有个明显的判断标准,就是在这个约束条件下,已经筛选掉了一部分结果了,例如,你这个i物品都已经超过这个最大承重了,当然这个i物品就不可以拿了呀.

当然,如果符合了约束条件,那么你的选择我就未知了,所以都要考虑到哦

也就是结果如果是以下:

能否成功:(选择1的结果)||(选择2的结果)

求最值:max(选择1的结果,选择2的结果,)

求累计数目:选择1的结果+选择2的结果,有一个前提是:两个约束条件下必须是互斥的才行.不然叠加的结果会有重复的结果哦,就是导致出错.

### 明天看调优,节省空间和降低维度,能一维尽量一维416

拿与不拿是一种选择,  加还是减也是选择.

目标值这个是约束,          **`这个题先考虑用回溯做!!!,然后再转换到动态规划`**

[2,2,2]  taget=2

dp i taget=数目

选择一,最后一个是加号,   a+b=sum,a-b=taget,,,    target=a= (sum+target)/2

拿就是     i>a,不拿 [i-1,target]

i<a 就是拿与不拿都可以, [i-1,target-arr[i]]+[i-1,target],拿不拿我不知道,但是这个任意的,在计算数目的时候,都需要累计上,

### 面试103

这个不是拿与不拿,是哪几个0-N个,  这是选择

总额为t,是约束

[i索引]  [累计和为t]=min硬币

变成:S1 拿不拿 S1 拿不拿,S1 S1 S1 S1

拿  [i] [t-s1],

不拿 [i-1] [t]

i-1问i的选择,问了i的选择,就能猜出结果集中还剩下多少!

一个索引 ,一个物品,他可以重叠,可以重复计算,

**八皇后和完全背包很像!!**

### 爬楼梯

```java
class Solution {
    public int climbStairs(int n) {
        if(n<=2){
            return n;
        }
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i=3;i<n+1;i++){
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
    } 
}
//求数量就是累加罢了.




```



### i的选择问题

i可以怎么选择:

0,1选择,放入与不放入,有与没有

完全选择,选几个,可以转换成01选择

与给定的target相不相等,等价与否,

01字符串在i索引,翻不翻转的问题

这都是两级化的问题

还有一个是i选择和谁搭伙?

是i的前元素,可以是多个的,这些 ,无论是计算数目,还是最值,都需要全部考虑进去,数目就相加,最值就挨个比较,

难一点的就是一个数组的双指针问题了,也就是j在前,i在后,但是j是固定的值罢了,













