### 递归

爷爷上半说唱

​      爸爸上半说唱  

​              儿子上半说唱

​              儿子下半说唱

​      爸爸下半说唱

爷爷下半说唱

sout {前面}

fun()

sout {后面}      爷前，爸前，儿前，儿后，爸后，爷后。

也就是说，儿子，最底层可以执行完整个代码。

![1652708658447](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1652708658447.png)

如图：

![1652708676569](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1652708676569.png)

第一个左边递归，是逻辑代码在左递归的后面，

也就是说，一直到儿子最底层代码，然后执行儿子的整个代码，因为没有父亲节点的前半段逻辑代码，

所以是先打印左儿子4，做完之后，回到爸爸节点，做爸爸的后半段逻辑代码，是打印爸爸节点2，进入爸爸为当前节点的又依次递归，这个时候，是不是直接打印5呢？？

当然不是，当前节点是5对吧，那是直接打印5吗，不是，是先。到最底层的左儿子节点，先打印它，再打印父节点，由于没有儿子，所以才打印5，然后回到爷爷的后半段逻辑，也就是打印爷爷节点1，然后进入爷爷的右孩子为当前节点的递归中，不是立马打印右孩子哦，而是重复上面步骤，先打印它的左...左孩子。



前序遍历

![1652711907040](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1652711907040.png)

在左递归的前面执行打印逻辑，那么就是先爷爷，再爸爸儿子，1，2，4返回，进入右，5，这里就是直接打印5了，和上面不同，因为这里的逻辑是左递归的前面，所以先打印5，后面就是先3.后6，

![1652712044710](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1652712044710.png)

看看后序，在递归后面，先是儿子把，4526731

先是最底层左儿子4打印，然后上去2，但是没到打印又进入递归了，进入5，没有孩子，打印5，回去2，打印2，回去1，但不打印，下到6打印6，上到3不打印，下到7，打印7，上到3，打印3，上到1，打印1.

> 技巧：如果说所有数据都能通过，那必须要进行数据的过滤对吧，也就是说要对数据进行严格的判断处理。例如，所以要考虑数据的来源，从严处理，把可能的数据来源都处理好！！。每一种情况都有可能。

![1652752314408](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1652752314408.png)

遍历每一条路径：

前序遍历，逻辑写在最上面，也就是爷爷上，爸爸上，儿子上，124，折回来，就是爸爸下了，然后是女儿全部，爸爸是12，进入女儿这里，12*10+5；

![1652752542665](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1652752542665.png)

### 前缀和与哈希表

![1652777291922](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1652777291922.png)

getordefault（path，0）拿到路径和出现的次数，如果拿不到就赋值为0，表示没有这个路径和，

最后一句话，map.put(path,map.get(path)-1) 这个什么意思呢？

我们知道两个递归都结束后的状态是什么，那就是遍历完了一整条路径了，也就是遍历完了一个新的数组了，那要重新指向新的数组，指向要把当前的求和去掉就行，它会返回上一次，也就是path[n-1]的求和，然后再结合一个节点，构成path[n]=path[n-1]+val[n];

记住遍历完一条完整路径后，需要把当前的路径和从哈希表中删除.

### 递归与回溯

fun(root){

fun(root.right)

list.add(root.val)

fun(root.left)

}

fun(index){

fun(index+1)

list.add(arr[index]);

fun(index+1)

}

其实index+1和root.left都是表示下一个指针,就是下一代!!也就是递归的层数往下再降一层.效果一样的哦.

fun(index+1)就是进入到儿子领域,等所有函数调用完,回溯到父节点.

if(递归到最底层的儿子){

结束执行语句.

}

select 1

fun(子1)

select2

fun(子2)

当前节点回溯逻辑(remove)

父亲和左右孩子,父亲先去左孩子这里,这个时候打个断点,等待左孩子执行完整个函数的所有逻辑,最后一步之后,就重新激活父亲节点,并继续执行父亲的后续逻辑,也就是fun(左儿子),后面的逻辑,selcet2,做完之后,又递归进入了右孩子的函数,等待执行完完整的右孩子的逻辑后,才激活父节点,做最后的一个收尾逻辑.至此整个函数的调用就到此结束.

![1652928955029](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1652928955029.png)

## 回溯-组合

### 面试题-79

如果是前序遍历,也就是部分的逻辑放在儿子的递归之前,也就是一到这个父亲节点的时候,就执行这部分的逻辑,并将这部分的逻辑处理完成的结果作为参数传递给她们的儿子,等待儿子处理完成以后,父亲最后将左儿子和右儿子的数据相加返回.这个是父节点要做的事情,如果有两个父节点.那么将两个父节点的值也封装起来,然后爷爷打包返回.这个就是父亲的完成逻辑,

父亲处理好一些(爷爷传递过来的)数据,然后再封装给儿子,父亲等待儿子们的结果,并封装返回.

父亲先处理-------封装传递------等待孩子完成处理----整合左右孩子的处理结果.

![1652929280123](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1652929280123.png)

后序遍历呢: 父亲还没干任何事情,就被传递给左儿子了,左儿子啥也不干,直接建立一个空集合返回,这个时候,父亲骂左孩子没用的东西,于是自己加入一些元素(父亲处理的逻辑),然后封装结果作为参数传递 给右孩子,右孩子将这个结果装入链表.至此右孩子做完了,返回父节点,父亲最后完善,这个是父亲添加的节点,由自己去删除它,做完收尾工作.  void只做清除工作,int父节点要做返回操作.

所以孩子们只做了一件事情,那就是将父亲给的结果封装到链表中,左孩子呢,父亲没做任何处理,将空数据给左孩子,**`这个suset参数为空`**也别怪左孩子无能了,是父亲太偏爱右孩子了,就是这个孩子的递归只是一个别的函数而已,注意哈,subset这个参数,可以被**父亲**改变,也**可以被儿子改变**的,我们看到**左儿子没有改变**subset只是添加到链表中而已.如果**右儿子**改变了的话,需要将这个数据清除哦.(**这就是右孩子**)

> **总结:**
>
> 参数:index       传入参数: index+1;
>
> 父亲:subset给左孩子是:内容为空    给右孩子:把父节点索引对应的值放入set
>
> 儿子对subset: 儿子都是将subset加入链表,做完后,把加入的数据清空.
>
> 一个函数可以认为当前是父节点,也可以是儿子节点.
>
> 那怎么判断?
>
> else if就是开始状态更多的是中间状态,而if是结束状态.
>
> 先递再归,先传参给儿子们,最后回到根节点,总结并返回.

由于是父亲自己改变的,儿子没动,那么父亲应该在自己的逻辑中删掉自己加的元素,不然不能返回哦.

一个自己定义的参数.首先是父亲处理,然后再交给儿子处理,儿子处理完以后,父亲接着处理,父亲处理了,右儿子处理,处理了之后,父节点善后.但无论是儿子还父亲,都必须要清除结果,再给上级传递.

### 面试题-80_无重复n选k个子集



![1653318359271](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1653318359271.png)

### 面试题-81_选元素可重子集和为8

![1653361931414](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1653361931414.png)



### 面试题-82_数组重复子集不可和8

![1653361976334](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1653361976334.png)

这个入参index有点意思:

两条路是加不加这个元素,这个元素在原数组重复,所以他应该是问:我这里有6个2,你要放入子集多少个2呢,

对吧,也不分顺序的加入,所以就像服务员给你倒水一样,一杯够吗? 不够,两杯,三杯,我这里总共有10杯酒,加到你喊停为止.这个是部分顺序的,  11111,这个五个1,无论是你加第1,3个的1,还是2,4的1,我都默认你是要加2个1,

故,第一个,我要了,故走index+1路,调到第二个1,我想要总共2个1,故ok了.

## 回溯-排列

> 递归这么抽象的东西一定要看动画演示图

### 面试题-83

子递归上面一句是,你对递归要做的目的,是选择,也是核心逻辑.

![1653488483716](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1653488483716.png)

这个其实是nmus.length数量的N叉树,

这里的J你就看成是常数,比如,和i偏移量为1的索引和i交换,和i偏移量为2的索引和i交换,这种选择是不一样的,但是有遵循着一种顺序,那就是轮流来,从第一个当老大,第二个当老大,第三个当老大,当完老大要退位.

递归help(i)和子递归help(i+1),表示索引会依次往下,意思是什么,就是第一个是原数组,第二个是从索引1开始的数组,第三个是索引2开始的数组,这只是部分,截掉了前面一点.

i的含义是什么,这个数组从哪个索引开始的,j表示和这个所谓的开始索引的偏移量,偏移量逐个增加,与开始索引交换位置,轮流当老大,这个老大不是整个数组的老大,而是部分数组的老大或者整个数组的老大.

小经验:

遇到问题,请你列出所有可能的选择列表,   注意 列出选择列表,然后看看这样选择,需要写出什么样的逻辑代码来,如果一样的话,可以用for循环,如果是两种可能,那就用二叉树就可以,



### 面试题-84



## 经典回溯题

### 生成括号



### 回文字符串

回文加上不可重复N排列,这个就可以搞懂回溯,83,86.

### 生成IP地址



### N皇后

## 二叉树的横向与纵向

### 横向

这个代码递归函数的子递归函数的个数

这个是**经过筛选**之后,可以选择的选择列表.例如被切割过的部分数组.他的一个开始和结束**连续**片段,或者是数组的**零散**符合条件的片段,第一次来的,选择列表一定是full的.下一次就是残缺的.

**横向需要重置,垂直方向不需要重置!!!!**

### 垂直



